{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home What is Fosscord? Fosscord is a free open source selfhostable chat, voice and video discord-compatible platform Why the name Fosscord? Fosscord is a combination of the abbreviation FOSS ( F ree O pen S ource S oftware) and the name Dis cord . Philosophy Fosscord aims to be a full one-on-one clone of Discord, adding more features that can be used as a replacement for the official client and still connect to discord.com and host private Fosscord server instances. Fosscord aims to give the best possible user experience, while being backwards compatible to Discord's features and adding new ones/improving old ones. The client can connect to multiple server instances without the need to open it multiple times. The client should be extensible through a secure Plugin and Theme System with own store. The server should be extensible through bots, just like discord without the need to change anything except the api endpoint. The project is open source so everyone can have a look what's going on under the hood and can be maintained and expanded by the community. Everything is configurable in the server config and everyone can add their own features, so that it is not opinionated. Concept Why backwards compatible to Discord? Benefit from the large user base of discord -> make a better client No disadvantage for the users who use fosscord, so that they can still communicate with all friends who use discord Discord has already built a great and stable protocol (don't reinvent the wheel) (We can still add additional features) Support Discord server If we are finished, we'll host our own support server.","title":"Home"},{"location":"#home","text":"","title":"Home"},{"location":"#what-is-fosscord","text":"Fosscord is a free open source selfhostable chat, voice and video discord-compatible platform","title":"What is Fosscord?"},{"location":"#why-the-name-fosscord","text":"Fosscord is a combination of the abbreviation FOSS ( F ree O pen S ource S oftware) and the name Dis cord .","title":"Why the name Fosscord?"},{"location":"#philosophy","text":"Fosscord aims to be a full one-on-one clone of Discord, adding more features that can be used as a replacement for the official client and still connect to discord.com and host private Fosscord server instances. Fosscord aims to give the best possible user experience, while being backwards compatible to Discord's features and adding new ones/improving old ones. The client can connect to multiple server instances without the need to open it multiple times. The client should be extensible through a secure Plugin and Theme System with own store. The server should be extensible through bots, just like discord without the need to change anything except the api endpoint. The project is open source so everyone can have a look what's going on under the hood and can be maintained and expanded by the community. Everything is configurable in the server config and everyone can add their own features, so that it is not opinionated.","title":"Philosophy"},{"location":"#concept","text":"","title":"Concept"},{"location":"#why-backwards-compatible-to-discord","text":"Benefit from the large user base of discord -> make a better client No disadvantage for the users who use fosscord, so that they can still communicate with all friends who use discord Discord has already built a great and stable protocol (don't reinvent the wheel) (We can still add additional features)","title":"Why backwards compatible to Discord?"},{"location":"#support","text":"Discord server If we are finished, we'll host our own support server.","title":"Support"},{"location":"contributing/","text":"Contributing Setup Clone all repositories: git clone --recurse-submodules -j8 https://github.com/fosscord/fosscord cd fosscord git submodule foreach \"git checkout master && git pull origin master\" Mongodb MongoDB local server Recommended : Secure, control over data and lower latency Install MongoDB locally and configure it: Edit the file (linux: /etc/mongod.conf , macos: /usr/local/etc/mongod.conf , windows: <install directory>\\bin\\mongod.cfg ) and add this to the end: replication: replSetName: \"rs0\" Restart MongoDB systemctl reload mongod Connect to mongodb mongo Setup replica set: rs.initiate() MongoDB Atlas/Cloud server Easier setup : But no data sovereignty and higher latency Register/login for free at cloud.mongodb.com (500mb limit) Create a new cluster Configure cluster: Sidebar -> Network Access (Security) -> IP Access List -> Add IP address -> Either \"Add current ip address\" or \"allow access from anywhere\" or the ip of your server -> Confirm Connect to cluster: Sidebar -> Clusters -> Connect -> \"Connect your application\" -> Copy connection string Looks similar to this: mongodb+srv://root:<password>@cluster.yjecb.mongodb.net/myFirstDatabase?retryWrites=true&w=majority Replace <password> with your password and myFirstDatabase with a name of your choice Add your connection string to the .env files: Create api/.env and gateway/.env file and add this MONGO_URL=YourConnectionString replace YourConnectionString with the mongodb connection string HTTP API Server cd api npm i npm start Make it public You need to set the gateway endpoint in order to access it from everywhere. To do this create a /api/.env file and appending/writing this: GATEWAY=[YOURGATEWAYURL] replace [YOURGATEWAYURL] with your gateway endpoint e.g. http://localhost:3001 , http://myfosscordserver:3001 WebSocket Gateway Server cd gateway npm i npm start Now you should have a development server running and can use the test client on http://localhost:3001 Docker Optionally if you want to use Docker: docker-compose up You can access it on http://localhost:3001","title":"Contributing"},{"location":"contributing/#contributing","text":"","title":"Contributing"},{"location":"contributing/#setup","text":"Clone all repositories: git clone --recurse-submodules -j8 https://github.com/fosscord/fosscord cd fosscord git submodule foreach \"git checkout master && git pull origin master\"","title":"Setup"},{"location":"contributing/#mongodb","text":"","title":"Mongodb"},{"location":"contributing/#mongodb-local-server","text":"Recommended : Secure, control over data and lower latency Install MongoDB locally and configure it: Edit the file (linux: /etc/mongod.conf , macos: /usr/local/etc/mongod.conf , windows: <install directory>\\bin\\mongod.cfg ) and add this to the end: replication: replSetName: \"rs0\" Restart MongoDB systemctl reload mongod Connect to mongodb mongo Setup replica set: rs.initiate()","title":"MongoDB local server"},{"location":"contributing/#mongodb-atlascloud-server","text":"Easier setup : But no data sovereignty and higher latency Register/login for free at cloud.mongodb.com (500mb limit) Create a new cluster Configure cluster: Sidebar -> Network Access (Security) -> IP Access List -> Add IP address -> Either \"Add current ip address\" or \"allow access from anywhere\" or the ip of your server -> Confirm Connect to cluster: Sidebar -> Clusters -> Connect -> \"Connect your application\" -> Copy connection string Looks similar to this: mongodb+srv://root:<password>@cluster.yjecb.mongodb.net/myFirstDatabase?retryWrites=true&w=majority Replace <password> with your password and myFirstDatabase with a name of your choice Add your connection string to the .env files: Create api/.env and gateway/.env file and add this MONGO_URL=YourConnectionString replace YourConnectionString with the mongodb connection string","title":"MongoDB Atlas/Cloud server"},{"location":"contributing/#http-api-server","text":"cd api npm i npm start","title":"HTTP API Server"},{"location":"contributing/#make-it-public","text":"You need to set the gateway endpoint in order to access it from everywhere. To do this create a /api/.env file and appending/writing this: GATEWAY=[YOURGATEWAYURL] replace [YOURGATEWAYURL] with your gateway endpoint e.g. http://localhost:3001 , http://myfosscordserver:3001","title":"Make it public"},{"location":"contributing/#websocket-gateway-server","text":"cd gateway npm i npm start Now you should have a development server running and can use the test client on http://localhost:3001","title":"WebSocket Gateway Server"},{"location":"contributing/#docker","text":"Optionally if you want to use Docker: docker-compose up You can access it on http://localhost:3001","title":"Docker"},{"location":"plugins/","text":"Philosophy Plugins are executed in their environment to prevent security issues Plugins can create their own UI and loaded in a separate view (similar to vscode extensions) Plugins can access the component Api and therefore extend the client UI Plugins can access the WebSocket Connection/Rest API and intercept/transform events Plugins are restricted and can only do actions with the corresponding permission Plugins should be accessible through a store that needs to verify the plugins (with dev options to sideload plugins/add other stores) Permissions Can't access the user's token (token plugins should rather be directly integrated into the client (e.g. account switcher)) All permissions must meet the purpose of the plugin and must justify why they need the certain permission to be approved Shouldn't be able to make any request, except if it: Requests permission to access the api of the network Requests permission to access a specific domain (e.g. plugins backend) Requests permission to access all domains Shouldn't be able to intercept events, except if it: Requests permission to a specific event(s) Requests permission to all events Needs to request permission to be able to extend the client's UI","title":"Plugins"},{"location":"plugins/#philosophy","text":"Plugins are executed in their environment to prevent security issues Plugins can create their own UI and loaded in a separate view (similar to vscode extensions) Plugins can access the component Api and therefore extend the client UI Plugins can access the WebSocket Connection/Rest API and intercept/transform events Plugins are restricted and can only do actions with the corresponding permission Plugins should be accessible through a store that needs to verify the plugins (with dev options to sideload plugins/add other stores)","title":"Philosophy"},{"location":"plugins/#permissions","text":"Can't access the user's token (token plugins should rather be directly integrated into the client (e.g. account switcher)) All permissions must meet the purpose of the plugin and must justify why they need the certain permission to be approved Shouldn't be able to make any request, except if it: Requests permission to access the api of the network Requests permission to access a specific domain (e.g. plugins backend) Requests permission to access all domains Shouldn't be able to intercept events, except if it: Requests permission to a specific event(s) Requests permission to all events Needs to request permission to be able to extend the client's UI","title":"Permissions"},{"location":"ressources/","text":"Project structure Fosscord consists of many repositories, which together make up the client and the server: Server-side fosscord-api is the REST HTTP API server. fosscord-gateway is the WebSocket Gateway server. fosscord-rtc will be the webrtc server for voice and video sharing. fosscord-dashboard An admin dashboard for the server (analytics, settings, administration, trust & safety) fosscord-server-util contains all shared logic like Database Models, Utility functions... fosscord-cdn is the content-delivery-content (CDN) that stores user uploaded images. fosscord-docs Documentation of Fosscord Client-side fosscord-ui is a user interface framework in the style of discord. fosscord-themes contains all the official themes for the client. fosscord-plugins contains all the official plugins for the client. fosscord-landingpage represents and explains the project. fosscord-client is the official Fosscord client. Discontinued react-native-withcss css-mediaquery Issues Naming convention The issue name must have the main label as a prefix in brackets: e.g. [Feature] Test or [Bug] Test . The first letter of the prefix and the title must be uppercase. You are not allowed to use CAPS.","title":"Ressources"},{"location":"ressources/#project-structure","text":"Fosscord consists of many repositories, which together make up the client and the server:","title":"Project structure"},{"location":"ressources/#server-side","text":"fosscord-api is the REST HTTP API server. fosscord-gateway is the WebSocket Gateway server. fosscord-rtc will be the webrtc server for voice and video sharing. fosscord-dashboard An admin dashboard for the server (analytics, settings, administration, trust & safety) fosscord-server-util contains all shared logic like Database Models, Utility functions... fosscord-cdn is the content-delivery-content (CDN) that stores user uploaded images. fosscord-docs Documentation of Fosscord","title":"Server-side"},{"location":"ressources/#client-side","text":"fosscord-ui is a user interface framework in the style of discord. fosscord-themes contains all the official themes for the client. fosscord-plugins contains all the official plugins for the client. fosscord-landingpage represents and explains the project. fosscord-client is the official Fosscord client.","title":"Client-side"},{"location":"ressources/#discontinued","text":"react-native-withcss css-mediaquery","title":"Discontinued"},{"location":"ressources/#issues","text":"","title":"Issues"},{"location":"ressources/#naming-convention","text":"The issue name must have the main label as a prefix in brackets: e.g. [Feature] Test or [Bug] Test . The first letter of the prefix and the title must be uppercase. You are not allowed to use CAPS.","title":"Naming convention"},{"location":"API/","text":"API Status overview This is the fosscord HTTP API Server. Every routes has its own issue . For documentation, head over to the Discord docs . If you want to work on a feature please comment on the corresponding issue so we can assign it you that nobody implements something twice.","title":"API"},{"location":"API/#api","text":"","title":"API"},{"location":"API/#status-overview","text":"This is the fosscord HTTP API Server. Every routes has its own issue . For documentation, head over to the Discord docs . If you want to work on a feature please comment on the corresponding issue so we can assign it you that nobody implements something twice.","title":"Status overview"},{"location":"API/configuration/","text":"Configuration Philosophy Every fosscord server instance should be completely configurable in every way, without the need to change the source code. The config should have reasonable defaults similar to discord. Only in special cases it should require a third party config value. The config should be changeable over the admin fosscord-dashboard and update in realtime without the need to restart the servers The very first time the server starts, it saves to default config in the database. The next start it will load the config from the database. Getting Started for Contributors You should not get() the Config in the root of your file and it instead load the config every time you access a value Import Config from fosscord-server-util: // at the top of the file import the Config file from /src/util/Config.ts import { Config } from \"@fosscord-server-util\" ; Access the Config in your route: router . get ( \"/\" , ( req : Request , res : Response ) => { // call Config.get() to get the whole config object and then just access the property you want const { allowNewRegistration } = Config . get (). register ; }); Config.get() returns the current config object and is not expensive at all Add own values to the Config The default Config is located in server-util /src/util/Config.ts and exports a interface DefaultOptions and a const DefaultOptions object with reasonable default values. To add your own values to the config, add the properties to the interface with corresponding types and add default values to const DefaultOptions . Also you don't need to worry about updating \"old config versions\", because new values will automatically be synced with the database. Note, however, that if the database already has a default value it won't update it.","title":"Configuration"},{"location":"API/configuration/#configuration","text":"","title":"Configuration"},{"location":"API/configuration/#philosophy","text":"Every fosscord server instance should be completely configurable in every way, without the need to change the source code. The config should have reasonable defaults similar to discord. Only in special cases it should require a third party config value. The config should be changeable over the admin fosscord-dashboard and update in realtime without the need to restart the servers The very first time the server starts, it saves to default config in the database. The next start it will load the config from the database.","title":"Philosophy"},{"location":"API/configuration/#getting-started-for-contributors","text":"You should not get() the Config in the root of your file and it instead load the config every time you access a value Import Config from fosscord-server-util: // at the top of the file import the Config file from /src/util/Config.ts import { Config } from \"@fosscord-server-util\" ; Access the Config in your route: router . get ( \"/\" , ( req : Request , res : Response ) => { // call Config.get() to get the whole config object and then just access the property you want const { allowNewRegistration } = Config . get (). register ; }); Config.get() returns the current config object and is not expensive at all","title":"Getting Started for Contributors"},{"location":"API/configuration/#add-own-values-to-the-config","text":"The default Config is located in server-util /src/util/Config.ts and exports a interface DefaultOptions and a const DefaultOptions object with reasonable default values. To add your own values to the config, add the properties to the interface with corresponding types and add default values to const DefaultOptions . Also you don't need to worry about updating \"old config versions\", because new values will automatically be synced with the database. Note, however, that if the database already has a default value it won't update it.","title":"Add own values to the Config"},{"location":"API/route/","text":"General All routes are located in the directory /src/routes/ and are loaded on start by a the lambert-server package. The HTTP API path is generated automatically based on the folder structure, so it is important that you name your files accordingly. If you want to use URL Params like :id in e.g. /users/:id you need to use # instead of : for the folder/filename, because of file naming issues on windows. index.ts files won't serve /api/index and instead alias the parent folder e.g. /api/ Your file needs to default export a express.Router() : import { Router } from express const router = Router (); export default router ; Now you can just use any regular express function on the router variable e.g: router . get ( \"/\" , ( req , res ) => {}); router . post ( \"/\" , ( req , res ) => {}); router . get ( \"/members\" , ( req , res ) => {}); Authentication Every request must contain the authorization header except the /login and /register route. You can add additional non-auth routes in /src/middlewares/Authentication.ts To access the user id for the current request use req.user_id Body Validation We use a custom body validation logic from lambert-server to check if the JSON body is valid. To import the function from /src/util/instanceOf.ts use: import { check } from \"/src/util/instanceOf\" ; Now you can use the middleware check for your routes by calling check with your Body Schema. router . post ( \"/\" , check (...), ( req , res ) => {}); Schema A Schema is a Object Structure with key-value objects that checks if the supplied body is an instance of the specified class. { id : String , roles : [ String ] } Notice if you use e.g. BigInt even if you can't supply it with JSON, it will automatically convert the supplied JSON number/string to a BigInt. Also if you want to check for an array of, just put the type inside [] Optional Parameter You can specify optional parameters if you prefix the key with a $ (dollar sign) e.g.: { $captcha: String } , this will make the captcha property in the body optional. Limit String length Additionally import the class Length from instanceOf and specify the type by making a new Length Object taking following parameters: import { Length } from \"/src/util/instanceOf\" ; const min = 2 ; const max = 32 ; const type = String ; { username : new Length ( min , max , type ) } this will limit the maximum string/number/array length to the min and max value. Example: import { check , Length } from \"/src/util/instanceOf\" ; const SCHEMA = { username : new Length ( 2 , 32 , String ), age : Number , $posts : [{ title : String }] } app . post ( \"/\" , check ( SCHEMA ), ( req , res ) => {}); Throw Errors If the body validation fails it will automatically throw an error. The errors structure is a key-value Object describing what field contained the error: { \"code\" : 50035 , \"message\" : \"Invalid Form Body\" , \"errors\" : { \"email\" : { \"_errors\" : [ { \"message\" : \"Email is already registered\" , \"code\" : \"EMAIL_ALREADY_REGISTERED\" } ] }, \"username\" : { \"_errors\" : [ { \"message\" : \"Must be between 2 - 32 in length\" , \"code\" : \"BASE_TYPE_BAD_LENGTH\" } ] } } } To manually throw a FieldError import FieldErrors import { FieldErrors } from /src/util/instanceOf To make sure your errors are understood in all languages translate it with i18next and req.t So after you have checked the field is invalid throw the FieldErrors throw FieldErrors (( login : { message : req.t ( \"auth:login.INVALID_LOGIN\" ), code : \"INVALID_LOGIN\" }});","title":"Route"},{"location":"API/route/#general","text":"All routes are located in the directory /src/routes/ and are loaded on start by a the lambert-server package. The HTTP API path is generated automatically based on the folder structure, so it is important that you name your files accordingly. If you want to use URL Params like :id in e.g. /users/:id you need to use # instead of : for the folder/filename, because of file naming issues on windows. index.ts files won't serve /api/index and instead alias the parent folder e.g. /api/ Your file needs to default export a express.Router() : import { Router } from express const router = Router (); export default router ; Now you can just use any regular express function on the router variable e.g: router . get ( \"/\" , ( req , res ) => {}); router . post ( \"/\" , ( req , res ) => {}); router . get ( \"/members\" , ( req , res ) => {});","title":"General"},{"location":"API/route/#authentication","text":"Every request must contain the authorization header except the /login and /register route. You can add additional non-auth routes in /src/middlewares/Authentication.ts To access the user id for the current request use req.user_id","title":"Authentication"},{"location":"API/route/#body-validation","text":"We use a custom body validation logic from lambert-server to check if the JSON body is valid. To import the function from /src/util/instanceOf.ts use: import { check } from \"/src/util/instanceOf\" ; Now you can use the middleware check for your routes by calling check with your Body Schema. router . post ( \"/\" , check (...), ( req , res ) => {});","title":"Body Validation"},{"location":"API/route/#schema","text":"A Schema is a Object Structure with key-value objects that checks if the supplied body is an instance of the specified class. { id : String , roles : [ String ] } Notice if you use e.g. BigInt even if you can't supply it with JSON, it will automatically convert the supplied JSON number/string to a BigInt. Also if you want to check for an array of, just put the type inside []","title":"Schema"},{"location":"API/route/#optional-parameter","text":"You can specify optional parameters if you prefix the key with a $ (dollar sign) e.g.: { $captcha: String } , this will make the captcha property in the body optional.","title":"Optional Parameter"},{"location":"API/route/#limit-string-length","text":"Additionally import the class Length from instanceOf and specify the type by making a new Length Object taking following parameters: import { Length } from \"/src/util/instanceOf\" ; const min = 2 ; const max = 32 ; const type = String ; { username : new Length ( min , max , type ) } this will limit the maximum string/number/array length to the min and max value.","title":"Limit String length"},{"location":"API/route/#example","text":"import { check , Length } from \"/src/util/instanceOf\" ; const SCHEMA = { username : new Length ( 2 , 32 , String ), age : Number , $posts : [{ title : String }] } app . post ( \"/\" , check ( SCHEMA ), ( req , res ) => {});","title":"Example:"},{"location":"API/route/#throw-errors","text":"If the body validation fails it will automatically throw an error. The errors structure is a key-value Object describing what field contained the error: { \"code\" : 50035 , \"message\" : \"Invalid Form Body\" , \"errors\" : { \"email\" : { \"_errors\" : [ { \"message\" : \"Email is already registered\" , \"code\" : \"EMAIL_ALREADY_REGISTERED\" } ] }, \"username\" : { \"_errors\" : [ { \"message\" : \"Must be between 2 - 32 in length\" , \"code\" : \"BASE_TYPE_BAD_LENGTH\" } ] } } } To manually throw a FieldError import FieldErrors import { FieldErrors } from /src/util/instanceOf To make sure your errors are understood in all languages translate it with i18next and req.t So after you have checked the field is invalid throw the FieldErrors throw FieldErrors (( login : { message : req.t ( \"auth:login.INVALID_LOGIN\" ), code : \"INVALID_LOGIN\" }});","title":"Throw Errors"},{"location":"API/structure/","text":"Translation We use i18next to manage translation/localization in some API Responses. The .json language files are located in /locales and are separated by namespaces. Source code We use TypeScript (JavaScript with types). The .ts source files are located in /src/ and will be compiled to .js in the /dist/ directory. Middlewares All Express Middlewares are in the directory /src/middlewares/ and need to be manually loaded in /src/Server.ts . Routes All Express Router Routes are in the directory /src/routes/ and are automatically registered based on the file structure. Models All Database Typescript interface models are in the directory /src/models/ Util All Utility functions are in the directory /src/util/ .","title":"Structure"},{"location":"API/structure/#translation","text":"We use i18next to manage translation/localization in some API Responses. The .json language files are located in /locales and are separated by namespaces.","title":"Translation"},{"location":"API/structure/#source-code","text":"We use TypeScript (JavaScript with types). The .ts source files are located in /src/ and will be compiled to .js in the /dist/ directory.","title":"Source code"},{"location":"API/structure/#middlewares","text":"All Express Middlewares are in the directory /src/middlewares/ and need to be manually loaded in /src/Server.ts .","title":"Middlewares"},{"location":"API/structure/#routes","text":"All Express Router Routes are in the directory /src/routes/ and are automatically registered based on the file structure.","title":"Routes"},{"location":"API/structure/#models","text":"All Database Typescript interface models are in the directory /src/models/","title":"Models"},{"location":"API/structure/#util","text":"All Utility functions are in the directory /src/util/ .","title":"Util"},{"location":"UI/","text":"Status overview This UI Framework includes all static Fosscord CSS Components. Usage: View the demo and make use of its source code .","title":"UI Framework"},{"location":"UI/#usage","text":"View the demo and make use of its source code .","title":"Usage:"},{"location":"UI/installation/","text":"Requirements You should be familiar with: Git NodeJS SCSS You could also just write plain CSS. (SCSS just adds some nice features) and the technologies we use for the UI. Getting Started Step 1 Clone the repository: git clone https://github.com/fosscord/fosscord-ui cd fosscord-ui Step 2 Install dependencies: npm install Step 3 Compile the SCSS: npm run scss Step 4 Open ./test/index.html for see the test page. Debugging VS Code The Launch file configuration is in ./vscode/launch.json , so you can just debug the server by pressing F5 or the > Launch Server button","title":"Installation"},{"location":"UI/installation/#requirements","text":"You should be familiar with: Git NodeJS SCSS You could also just write plain CSS. (SCSS just adds some nice features) and the technologies we use for the UI.","title":"Requirements"},{"location":"UI/installation/#getting-started","text":"","title":"Getting Started"},{"location":"UI/installation/#step-1","text":"Clone the repository: git clone https://github.com/fosscord/fosscord-ui cd fosscord-ui","title":"Step 1"},{"location":"UI/installation/#step-2","text":"Install dependencies: npm install","title":"Step 2"},{"location":"UI/installation/#step-3","text":"Compile the SCSS: npm run scss","title":"Step 3"},{"location":"UI/installation/#step-4","text":"Open ./test/index.html for see the test page.","title":"Step 4"},{"location":"UI/installation/#debugging","text":"","title":"Debugging"},{"location":"UI/installation/#vs-code","text":"The Launch file configuration is in ./vscode/launch.json , so you can just debug the server by pressing F5 or the > Launch Server button","title":"VS Code"},{"location":"UI/write_a_component/","text":"Every Component should have a demo/test page to see how the Component looks like. To create a test page in /test/ copy template.html , save it as a new file yourComponentName.html and open it in your browser. Now create a new file in /scss/ e.g. yourComponentName.scss and write some (S)CSS. To import your scss file edit /scss/index.scss and add this line: @ import \"yourComponentName.scss\" ; Now start the scss bundler with npm run scss Also make sure create all sort of various states of your component to see how it looks. If you are finished commit and push your changes. For non-maintainers, create a Pull Request ;)","title":"Write a component"},{"location":"client/","text":"","title":"Client"},{"location":"gateway/","text":"Gateway Status overview This is the fosscord WebSocket Gateway Server. For documentation, head over to the Discord docs . If you want to work on a feature please comment on the corresponding issue so we can assign it you that nobody implements something twice.","title":"Gateway"},{"location":"gateway/#gateway","text":"","title":"Gateway"},{"location":"gateway/#status-overview","text":"This is the fosscord WebSocket Gateway Server. For documentation, head over to the Discord docs . If you want to work on a feature please comment on the corresponding issue so we can assign it you that nobody implements something twice.","title":"Status overview"},{"location":"gateway/structure/","text":"For the WebSocket, we use ws and we'll write our own packet handler for the individual opcodes and events.","title":"Structure"},{"location":"server_util/database/","text":"Database Philosophy We create mongoose models and typescript interfaces for every data structure in the database. We use strings for all id's and for bitfields we use bigint's Documentation Have a look at the mongoose documentation to get familiar with it or watch this tutorial Getting Started import mongoose from \"mongoose\" ; and now you can query the database, here are some examples: import { GuildModel } from \"fosscord-server-util\" ; await new GuildModel ({ ... }). save (); // inserts a new guild const guild = await GuildModel . findOne ({ id : ... }). exec (); // searches for a guild Models We have mongoose Database Models and additionally TypeScript Interfaces . They are located in the repo fosscord-server-util under /src/models/ . To add your own Database Model, create a new file and export the model and the interface. Example: export interface Event extends Document { guild_id? : bigint ; user_id? : bigint ; channel_id? : bigint ; created_at? : number ; event : EVENT ; data? : any ; } export const EventSchema = new Schema ({ guild_id : Types.Long , user_id : Types.Long , channel_id : Types.Long , created_at : { type : Number , required : true }, event : { type : String , required : true }, data : Object , }); export const EventModel = model < Event > ( \"Event\" , EventSchema , \"events\" ); Emit events Most Routes modify the database and therefore need to inform the clients with events for data changes. (Events are stored in a MongoDB Event Store collection and distributed to the individual gateway servers) You can find all events on the discord docs page and in server-util/src/modesl/Event.ts To emit an event import the emitEvent function from /src/util/Event.ts import { emitEvent } from \"../../../util/Event\" ; this will take a the following parameters: { guild_id? : bigint ; // specify this if this event should be sent to all guild members channel_id? : bigint ; // specify this if this event should be sent to all channel members (e.g. group dm) user_id? : bigint ; // specify this if this event should be sent to the specific user event : string ; // the EVENTNAME, you can find all gateway event names in the fosscord-server-util Events file data? : any ; // event payload data } For easy intellisense, annotate the parameter with the corresponding Event interface from fosscord-server-util : import { GuildDeleteEvent } from \"fosscord-server-util\" ; emitEvent ({...} as GuildDeleteEvent ); // or with <> brackets: emitEvent ( < GuildDeleteEvent > {...}); Example Putting it all together: await emitEvent ({ event : \"GUILD_DELETE\" , data : { id : guildID , }, guild_id : guildID , } as GuildDeleteEvent );","title":"Database"},{"location":"server_util/database/#database","text":"","title":"Database"},{"location":"server_util/database/#philosophy","text":"We create mongoose models and typescript interfaces for every data structure in the database. We use strings for all id's and for bitfields we use bigint's","title":"Philosophy"},{"location":"server_util/database/#documentation","text":"Have a look at the mongoose documentation to get familiar with it or watch this tutorial","title":"Documentation"},{"location":"server_util/database/#getting-started","text":"import mongoose from \"mongoose\" ; and now you can query the database, here are some examples: import { GuildModel } from \"fosscord-server-util\" ; await new GuildModel ({ ... }). save (); // inserts a new guild const guild = await GuildModel . findOne ({ id : ... }). exec (); // searches for a guild","title":"Getting Started"},{"location":"server_util/database/#models","text":"We have mongoose Database Models and additionally TypeScript Interfaces . They are located in the repo fosscord-server-util under /src/models/ . To add your own Database Model, create a new file and export the model and the interface. Example: export interface Event extends Document { guild_id? : bigint ; user_id? : bigint ; channel_id? : bigint ; created_at? : number ; event : EVENT ; data? : any ; } export const EventSchema = new Schema ({ guild_id : Types.Long , user_id : Types.Long , channel_id : Types.Long , created_at : { type : Number , required : true }, event : { type : String , required : true }, data : Object , }); export const EventModel = model < Event > ( \"Event\" , EventSchema , \"events\" );","title":"Models"},{"location":"server_util/database/#emit-events","text":"Most Routes modify the database and therefore need to inform the clients with events for data changes. (Events are stored in a MongoDB Event Store collection and distributed to the individual gateway servers) You can find all events on the discord docs page and in server-util/src/modesl/Event.ts To emit an event import the emitEvent function from /src/util/Event.ts import { emitEvent } from \"../../../util/Event\" ; this will take a the following parameters: { guild_id? : bigint ; // specify this if this event should be sent to all guild members channel_id? : bigint ; // specify this if this event should be sent to all channel members (e.g. group dm) user_id? : bigint ; // specify this if this event should be sent to the specific user event : string ; // the EVENTNAME, you can find all gateway event names in the fosscord-server-util Events file data? : any ; // event payload data } For easy intellisense, annotate the parameter with the corresponding Event interface from fosscord-server-util : import { GuildDeleteEvent } from \"fosscord-server-util\" ; emitEvent ({...} as GuildDeleteEvent ); // or with <> brackets: emitEvent ( < GuildDeleteEvent > {...});","title":"Emit events"},{"location":"server_util/database/#example","text":"Putting it all together: await emitEvent ({ event : \"GUILD_DELETE\" , data : { id : guildID , }, guild_id : guildID , } as GuildDeleteEvent );","title":"Example"},{"location":"server_util/permissions/","text":"To get the permission for a guild member import the getPermission from fosscord-server-util . import { getPermission } from \"fosscord-server-util\" ; The first argument is the user_id the second the guild_id and the third an optional channel_id const permissions = await getPermission ( user_id : string , guild_id : string , channel_id? : string ) const permissions = await getPermission ( \"106142653265366125\" , \"4061326832657368175\" ) Example const perms = await getPermission ( req . userid , guild_id ); // preferred method: Use this if you want to check if a user lacks a certain permission and abort the operation perms . hasThrow ( \"MANAGE_GUILD\" ) // will throw an error if the users lacks the permission if ( perms . has ( \"MANAGE_GUILD\" )) { ... }","title":"Permissions"},{"location":"server_util/permissions/#example","text":"const perms = await getPermission ( req . userid , guild_id ); // preferred method: Use this if you want to check if a user lacks a certain permission and abort the operation perms . hasThrow ( \"MANAGE_GUILD\" ) // will throw an error if the users lacks the permission if ( perms . has ( \"MANAGE_GUILD\" )) { ... }","title":"Example"}]}