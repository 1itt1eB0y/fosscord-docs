{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home What is Fosscord? Fosscord is a free open source selfhostable discord compatible chat, voice and video platform Why the name Fosscord? Fosscord is a combination of the abbreviation FOSS ( F ree O pen S ource S oftware) and the name Dis cord . Philosophy Fosscord aims to be a full one-on-one clone of Discord, adding more features that can be used as a replacement for the official client and still connect to discord.com and host private Fosscord server instances. Fosscord aims to give the best possible user experience, while being backwards compatible to Discord's features and adding new ones/improving old ones while maintaining the user privacy with end-to-end encryption support. The client can connect to multiple server instances without the need to open it multiple times. The client should be extensible through a secure Plugin and Theme System with own store. The server should be extensible through bots, just like discord without the need to change anything except the api endpoint. The project is open source so everyone can have a look what's going on under the hood and can be maintained and expanded by the community. Everything is configurable in the server config and everyone can add their own features, so that it is not opinionated. Concept Why backwards compatible to Discord? Benefit from the large user base of discord -> more users, making the switch easier for new users & keeping workflows intact No disadvantage for the users who use fosscord, so that they can still communicate with all their peers who use discord Discord has already built a great and stable protocol (don't reinvent the wheel) The community can extend and customize their clients and servers by selfhosting them and developing and installing addons Support Discord server Ones we are finished, we'll host our own instance to host the support server.","title":"Home"},{"location":"#home","text":"","title":"Home"},{"location":"#what-is-fosscord","text":"Fosscord is a free open source selfhostable discord compatible chat, voice and video platform","title":"What is Fosscord?"},{"location":"#why-the-name-fosscord","text":"Fosscord is a combination of the abbreviation FOSS ( F ree O pen S ource S oftware) and the name Dis cord .","title":"Why the name Fosscord?"},{"location":"#philosophy","text":"Fosscord aims to be a full one-on-one clone of Discord, adding more features that can be used as a replacement for the official client and still connect to discord.com and host private Fosscord server instances. Fosscord aims to give the best possible user experience, while being backwards compatible to Discord's features and adding new ones/improving old ones while maintaining the user privacy with end-to-end encryption support. The client can connect to multiple server instances without the need to open it multiple times. The client should be extensible through a secure Plugin and Theme System with own store. The server should be extensible through bots, just like discord without the need to change anything except the api endpoint. The project is open source so everyone can have a look what's going on under the hood and can be maintained and expanded by the community. Everything is configurable in the server config and everyone can add their own features, so that it is not opinionated.","title":"Philosophy"},{"location":"#concept","text":"","title":"Concept"},{"location":"#why-backwards-compatible-to-discord","text":"Benefit from the large user base of discord -> more users, making the switch easier for new users & keeping workflows intact No disadvantage for the users who use fosscord, so that they can still communicate with all their peers who use discord Discord has already built a great and stable protocol (don't reinvent the wheel) The community can extend and customize their clients and servers by selfhosting them and developing and installing addons","title":"Why backwards compatible to Discord?"},{"location":"#support","text":"Discord server Ones we are finished, we'll host our own instance to host the support server.","title":"Support"},{"location":"resources/","text":"Links Documentation Roadmap (Notion to-do board synced with GitHub issues) Status (Status page of the offical foscord instance) GitHub (GitHub organization) OpenCollective (Financially support the project to cover server costs and other expenses) Discord server (for support & organization (If we are finished we'll host our own support server)) Tor Hidden Service (Better privacy for TOR users) Project structure Fosscord consists of many repositories, which together make up the client and the server: Server fosscord-server is the complete Fosscord Server Contains: api a HTTP REST server gateway a WebSocket Gateway server rtc a C++ webrtc server for voice and video sharing. webrtc-server a javascript webrtc server for voice and video communication dashboard An admin dashboard for the server (analytics, settings, administration, trust & safety) util contains all shared logic like Database Models, Utility functions... cdn is the content-delivery-content (CDN) that stores user uploaded images. Client fosscord-ui is a user interface framework in the style of discord. fosscord-themes contains all the official themes for the client. fosscord-plugins contains all the official plugins for the client. fosscord-client is the official Fosscord client. fosscord-client-native is the official (react)-native Fosscord client. ~~ react-native-withcss CSS support for react native~~ (Discontinued) ~~ css-mediaquery CSS media query support for react native~~ (Discontinued) Others fosscord-docs Documentation of Fosscord fosscord-landingpage represents and explains the project. fosscord.js A powerful JavaScript library for interacting with the Fosscord API fosscord.js-builders A collection of builders that you can use when creating your bot. fosscord.py An API wrapper for Fosscord written in Python. docker \ud83d\udc33 Fosscord's Docker images and composing","title":"Resources"},{"location":"resources/#links","text":"Documentation Roadmap (Notion to-do board synced with GitHub issues) Status (Status page of the offical foscord instance) GitHub (GitHub organization) OpenCollective (Financially support the project to cover server costs and other expenses) Discord server (for support & organization (If we are finished we'll host our own support server)) Tor Hidden Service (Better privacy for TOR users)","title":"Links"},{"location":"resources/#project-structure","text":"Fosscord consists of many repositories, which together make up the client and the server:","title":"Project structure"},{"location":"resources/#server","text":"fosscord-server is the complete Fosscord Server Contains: api a HTTP REST server gateway a WebSocket Gateway server rtc a C++ webrtc server for voice and video sharing. webrtc-server a javascript webrtc server for voice and video communication dashboard An admin dashboard for the server (analytics, settings, administration, trust & safety) util contains all shared logic like Database Models, Utility functions... cdn is the content-delivery-content (CDN) that stores user uploaded images.","title":"Server"},{"location":"resources/#client","text":"fosscord-ui is a user interface framework in the style of discord. fosscord-themes contains all the official themes for the client. fosscord-plugins contains all the official plugins for the client. fosscord-client is the official Fosscord client. fosscord-client-native is the official (react)-native Fosscord client. ~~ react-native-withcss CSS support for react native~~ (Discontinued) ~~ css-mediaquery CSS media query support for react native~~ (Discontinued)","title":"Client"},{"location":"resources/#others","text":"fosscord-docs Documentation of Fosscord fosscord-landingpage represents and explains the project. fosscord.js A powerful JavaScript library for interacting with the Fosscord API fosscord.js-builders A collection of builders that you can use when creating your bot. fosscord.py An API wrapper for Fosscord written in Python. docker \ud83d\udc33 Fosscord's Docker images and composing","title":"Others"},{"location":"setup/","text":"Setup Server Download This is the stable fosscord-server release. Download the server release from GitHub for your operating system. (Size ~60mb) Double click the file to start the server. (The first time it takes longer as it needs to setup the server) You can now access it on http://localhost:3001 . With terminal/shell This is the latest bleeding edge version of fosscord-server, which may have bugs. You need to install git from git-scm.com or your package manager. You need to install nodejs from nodejs.org or your package manager. Now you can clone and start the server by executing this in the terminal/shell: git clone https://github.com/fosscord/fosscord-server cd fosscord-server/bundle npm install npm start You can now access it on http://localhost:3001 Docker Optionally if you want to use Docker: git clone https://github.com/fosscord/fosscord-server cd fosscord-server docker-compose up You can now access it on http://localhost:3001","title":"Setup Server"},{"location":"setup/#setup-server","text":"","title":"Setup Server"},{"location":"setup/#download","text":"This is the stable fosscord-server release. Download the server release from GitHub for your operating system. (Size ~60mb) Double click the file to start the server. (The first time it takes longer as it needs to setup the server) You can now access it on http://localhost:3001 .","title":"Download"},{"location":"setup/#with-terminalshell","text":"This is the latest bleeding edge version of fosscord-server, which may have bugs. You need to install git from git-scm.com or your package manager. You need to install nodejs from nodejs.org or your package manager. Now you can clone and start the server by executing this in the terminal/shell: git clone https://github.com/fosscord/fosscord-server cd fosscord-server/bundle npm install npm start You can now access it on http://localhost:3001","title":"With terminal/shell"},{"location":"setup/#docker","text":"Optionally if you want to use Docker: git clone https://github.com/fosscord/fosscord-server cd fosscord-server docker-compose up You can now access it on http://localhost:3001","title":"Docker"},{"location":"api/","text":"Routes const ui = SwaggerUIBundle({ url: 'https://raw.githubusercontent.com/fosscord/fosscord-server/master/api/assets/openapi.json', dom_id: '#swagger-ui', })","title":"Routes"},{"location":"api/#routes","text":"const ui = SwaggerUIBundle({ url: 'https://raw.githubusercontent.com/fosscord/fosscord-server/master/api/assets/openapi.json', dom_id: '#swagger-ui', })","title":"Routes"},{"location":"api/encryption/","text":"Encryption Philosophy Everything should be end-to-end encrypted by default. Everything should be configurable by the user/admin to their security needs. Once encryption is enabled you can't disable it anymore. (Plain text channels need be created as such) End to end encryption should also be possible on unsupported servers e.g. discord.com. (through special formatted messages) Based on the concept that the server cannot be trusted and could be compromised. more coming soon","title":"Encryption"},{"location":"api/encryption/#encryption","text":"","title":"Encryption"},{"location":"api/encryption/#philosophy","text":"Everything should be end-to-end encrypted by default. Everything should be configurable by the user/admin to their security needs. Once encryption is enabled you can't disable it anymore. (Plain text channels need be created as such) End to end encryption should also be possible on unsupported servers e.g. discord.com. (through special formatted messages) Based on the concept that the server cannot be trusted and could be compromised. more coming soon","title":"Philosophy"},{"location":"client/plugins/","text":"Plugins Philosophy Plugins are executed in their environment to prevent security issues Plugins can create their own UI and loaded in a separate view (similar to vscode extensions) Plugins can access the component Api and therefore extend the client UI Plugins can access the WebSocket Connection/Rest API and intercept/transform events Plugins are restricted and can only do actions with the corresponding permission Plugins should be accessible through a store that needs to verify the plugins (with dev options to sideload plugins/add other stores) Permissions Can't access the user's token (token plugins should rather be directly integrated into the client (e.g. account switcher)) All permissions must meet the purpose of the plugin and must justify why they need the certain permission to be approved Shouldn't be able to make any request, except if it: Requests permission to access the api of the network Requests permission to access a specific domain (e.g. plugins backend) Requests permission to access all domains Shouldn't be able to intercept events, except if it: Requests permission to a specific event(s) Requests permission to all events Needs to request permission to be able to extend the client's UI more coming soon","title":"Plugins"},{"location":"client/plugins/#plugins","text":"","title":"Plugins"},{"location":"client/plugins/#philosophy","text":"Plugins are executed in their environment to prevent security issues Plugins can create their own UI and loaded in a separate view (similar to vscode extensions) Plugins can access the component Api and therefore extend the client UI Plugins can access the WebSocket Connection/Rest API and intercept/transform events Plugins are restricted and can only do actions with the corresponding permission Plugins should be accessible through a store that needs to verify the plugins (with dev options to sideload plugins/add other stores)","title":"Philosophy"},{"location":"client/plugins/#permissions","text":"Can't access the user's token (token plugins should rather be directly integrated into the client (e.g. account switcher)) All permissions must meet the purpose of the plugin and must justify why they need the certain permission to be approved Shouldn't be able to make any request, except if it: Requests permission to access the api of the network Requests permission to access a specific domain (e.g. plugins backend) Requests permission to access all domains Shouldn't be able to intercept events, except if it: Requests permission to a specific event(s) Requests permission to all events Needs to request permission to be able to extend the client's UI more coming soon","title":"Permissions"},{"location":"client/themes/","text":"Themes Philosophy Themes should look the same on all platforms Themes should be made with an visual theme editor to easily create and edit your own themes Themes should be combinable to use multiple themes at once Themes should be installed and submitted through a theme store with voting options Guilds should be able to specify their own themes more coming soon","title":"Themes"},{"location":"client/themes/#themes","text":"","title":"Themes"},{"location":"client/themes/#philosophy","text":"Themes should look the same on all platforms Themes should be made with an visual theme editor to easily create and edit your own themes Themes should be combinable to use multiple themes at once Themes should be installed and submitted through a theme store with voting options Guilds should be able to specify their own themes more coming soon","title":"Philosophy"},{"location":"contributing/server/","text":"Server Requirements Follow the server setup guide to setup the development environment Gateway The Gateway is a WebSocket server that is responsible for listening and emitting events. You can find the Roadmap overview here . For documentation, head over to the Discord docs . (our own documention is not written yet) If you want to work on a feature please comment on the corresponding issue so we can assign it you that nobody implements something twice. For the WebSocket, we use ws and we'll write our own packet handler for the individual opcodes and events. API The API is a HTTP REST server that process requests and manipulates the database. You can find the api documentation here . You can find the Roadmap overview here . Every route has its own issue . If you want to work on a feature please comment on the corresponding issue or write us on our development server so we can assign and discuss it and nobody implements something twice. Structure You can find the API directory in the fosscord-server Github repository. Inside it you can find: Translation We use i18next to manage translation/localization in some API Responses. The .json language files are located in /api/locales/ and are separated by namespaces. Source code We use TypeScript (JavaScript with types). The .ts source files are located in /api/src/ and will be compiled to .js in the /api/dist/ directory. Middlewares All Express Middlewares are in /api/src/middlewares/ and need to be manually loaded by /api/src/Server.ts . Routes All Express Router routes are in /api/src/routes/ and are automatically registered based on the file structure. Models All database TypeORM entities are located in /util/src/entities Util All Utility functions are in the directory /src/util/ and in @fosscord/util Configuration Philosophy Every fosscord server instance should be completely configurable in every way, without the need to change the source code. The config should have reasonable defaults similar to discord. Only in special cases it should require a third party config value. The config should be changeable over the admin fosscord-dashboard and update in realtime without the need to restart the servers The very first time the server starts, it saves to default config in the database. The next start it will load the config from the database. Example You should not get() the Config in the root of your file and it instead load the config every time you access a value Import Config from fosscord-server-util: // at the top of the file import the Config file from /src/util/Config.ts import { Config } from \"@fosscord-server-util\" ; Access the Config in your route: router . get ( \"/\" , ( req : Request , res : Response ) => { // call Config.get() to get the whole config object and then just access the property you want const { allowNewRegistration } = Config . get (). register ; }); Config.get() returns the current config object and is not expensive at all Extending The default Config is located in server-util /src/util/Config.ts and exports a interface DefaultOptions and a const DefaultOptions object with reasonable default values. To add your own values to the config, add the properties to the interface with corresponding types and add default values to const DefaultOptions . Also you don't need to worry about updating \"old config versions\", because new values will automatically be synced with the database. Note, however, that if the database already has a default value it won't update it. Routes All routes are located in the directory /src/routes/ and are loaded on start by a the lambert-server package. The HTTP API path is generated automatically based on the folder structure, so it is important that you name your files accordingly. If you want to use URL Params like :id in e.g. /users/:id you need to use # instead of : for the folder/filename, because of file naming issues on windows. index.ts files won't serve /api/index and instead alias the parent folder e.g. /api/ Your file needs to default export a express.Router() : import { Router } from express ; const router = Router (); export default router ; Now you can just use any regular express function on the router variable e.g: router . get ( \"/\" , ( req , res ) => {}); router . post ( \"/\" , ( req , res ) => {}); router . get ( \"/members\" , ( req , res ) => {}); Authentication Every request must contain the authorization header except the /login and /register route. You can add additional non-auth routes in /src/middlewares/Authentication.ts To access the user id for the current request use req.user_id Body Validation We use a custom body validation logic from lambert-server to check if the JSON body is valid. To import the function from /src/util/instanceOf.ts use: import { check } from \"/src/util/instanceOf\" ; Now you can use the middleware check for your routes by calling check with your Body Schema. router . post ( \"/\" , check (...), ( req , res ) => {}); Schema A Schema is a Object Structure with key-value objects that checks if the supplied body is an instance of the specified class. { id : String , roles : [ String ] } Notice if you use e.g. BigInt even if you can't supply it with JSON, it will automatically convert the supplied JSON number/string to a BigInt. Also if you want to check for an array of, just put the type inside [] Optional Parameter You can specify optional parameters if you prefix the key with a $ (dollar sign) e.g.: { $captcha: String } , this will make the captcha property in the body optional. Limit String length Additionally import the class Length from instanceOf and specify the type by making a new Length Object taking following parameters: import { Length } from \"/src/util/instanceOf\" ; const min = 2 ; const max = 32 ; const type = String ; { username : new Length ( min , max , type ); } this will limit the maximum string/number/array length to the min and max value. Example import { check , Length } from \"/src/util/instanceOf\" ; const SCHEMA = { username : new Length ( 2 , 32 , String ), age : Number , $posts : [{ title : String }] }; app . post ( \"/\" , check ( SCHEMA ), ( req , res ) => {}); Throw Errors If the body validation fails it will automatically throw an error. The errors structure is a key-value Object describing what field contained the error: { \"code\" : 50035 , \"message\" : \"Invalid Form Body\" , \"errors\" : { \"email\" : { \"_errors\" : [ { \"message\" : \"Email is already registered\" , \"code\" : \"EMAIL_ALREADY_REGISTERED\" } ] }, \"username\" : { \"_errors\" : [ { \"message\" : \"Must be between 2 - 32 in length\" , \"code\" : \"BASE_TYPE_BAD_LENGTH\" } ] } } } To manually throw a FieldError import FieldErrors import { FieldErrors } from / src / iltu / instanceOf ; To make sure your errors are understood in all languages translate it with i18next and req.t So after you have checked the field is invalid throw the FieldErrors throw FieldErrors (( login : { message : req.t ( \"auth:login.INVALID_LOGIN\" ), code : \"INVALID_LOGIN\" }}); Database Philosophy The instance hoster should be able to use any database they want for their specific size and purpose. That is why we use typeorm for database entities (models) for every data structure we use, because typeorm supports many different database engines. We use strings for all ids and bitfields (Tho when working with bitfields we convert it to BigInts and pass it to the utility BitField class) General Have a look at the typeorm documentation to get familiar with it or watch this tutorial . TypeORM supports MySQL, MariaDB, Postgres, CockroachDB, SQLite, Microsoft SQL Server, Oracle, SAP Hana, sql.js Getting Started Import the entity you want to select, manipulate, delete or insert from @fosscord/util List of all entities : Application, Attachment, AuditLog, Ban, BaseClass, Channel, Config, ConnectedAccount, Emoji, Guild, Invite, Member, Message, RateLimit, ReadState, Recipient, Relationship, Role, Sticker, Team, TeamMember, Template, User, VoiceState, Webhook Example database query import { Guild } from \"fosscord-server-util\" ; await new Guild ({ ... }). save (); // inserts a new guild or updates it if it already exists const guild = await Guild . findOne ({ id : \"23948723947932\" }). exec (); // searches for a guild await Guild . delete ({ owner_id : \"34975309473\" }) // deletes all guilds of the specific owner Entities The typeorm database entities are located in util/src/entities/ . To add your own database entity, create a new file, export the model and import/export it in util/src/entities/index.ts . Example entity @Entity ( \"users\" ) export class User extends BaseClass { // id column is automatically added by BaseClass @Column () username : string ; @JoinColumn ({ name : \"connected_account_ids\" }) @OneToMany (() => ConnectedAccount , ( account : ConnectedAccount ) => account . user ) connected_accounts : ConnectedAccount []; static async getPublicUser ( user_id : string , opts? : FindOneOptions < User > ) { return await User . findOneOrFail ( { id : user_id }, { ... opts , select : [... PublicUserProjection , ...( opts ? . select || [])] } ); } } Emit Events Most Routes modify the database and therefore need to inform the clients with events for data changes. Events are either stored locally if the server was started through the bundle or in RabbitMQ and are distributed to the gateway servers. You can find all events on the discord docs page and in util/src/interfaces/Event.ts . To emit an event import the emitEvent function from @fosscord/util import { emitEvent } from \"../../../util/Event\" ; You need to specify whom you want to send the event to, to do that either pass guild_id , user_id or channel_id . Additionally you need to set the eventname e.g. GUILD_DELETE . { guild_id? : bigint ; // specify this if this event should be sent to all guild members channel_id? : bigint ; // specify this if this event should be sent to all channel members user_id? : bigint ; // specify this if this event should be sent to the specific user event : string ; // the EVENTNAME, you can find all gateway event names in the @fosscord/util Events file data? : any ; // event payload data } For easy intellisense, annotate the parameter with the corresponding Event interface from @fosscord/util : import { GuildDeleteEvent } from \"@fosscord/util\" ; emitEvent ({...} as GuildDeleteEvent ); Example Putting it all together: await emitEvent ({ user_id : \"3297349345345874\" , event : \"GUILD_DELETE\" , data : { id : \"96784598743975349\" , }, } as GuildDeleteEvent ); Permissions To get the permission for a guild member import the getPermission from fosscord-server-util . import { getPermission } from \"fosscord-server-util\" ; The first argument is the user_id the second the guild_id and the third an optional channel_id const permissions = await getPermission ( user_id : string , guild_id : string , channel_id? : string ) const permissions = await getPermission ( \"106142653265366125\" , \"4061326832657368175\" ) Example const perms = await getPermission ( req . userid , guild_id ); // preferred method: Use this if you want to check if a user lacks a certain permission and abort the operation perms . hasThrow ( \"MANAGE_GUILD\" ) // will throw an error if the users lacks the permission if ( perms . has ( \"MANAGE_GUILD\" )) { ... }","title":"Server"},{"location":"contributing/server/#server","text":"","title":"Server"},{"location":"contributing/server/#requirements","text":"Follow the server setup guide to setup the development environment","title":"Requirements"},{"location":"contributing/server/#gateway","text":"The Gateway is a WebSocket server that is responsible for listening and emitting events. You can find the Roadmap overview here . For documentation, head over to the Discord docs . (our own documention is not written yet) If you want to work on a feature please comment on the corresponding issue so we can assign it you that nobody implements something twice. For the WebSocket, we use ws and we'll write our own packet handler for the individual opcodes and events.","title":"Gateway"},{"location":"contributing/server/#api","text":"The API is a HTTP REST server that process requests and manipulates the database. You can find the api documentation here . You can find the Roadmap overview here . Every route has its own issue . If you want to work on a feature please comment on the corresponding issue or write us on our development server so we can assign and discuss it and nobody implements something twice.","title":"API"},{"location":"contributing/server/#structure","text":"You can find the API directory in the fosscord-server Github repository. Inside it you can find:","title":"Structure"},{"location":"contributing/server/#translation","text":"We use i18next to manage translation/localization in some API Responses. The .json language files are located in /api/locales/ and are separated by namespaces.","title":"Translation"},{"location":"contributing/server/#source-code","text":"We use TypeScript (JavaScript with types). The .ts source files are located in /api/src/ and will be compiled to .js in the /api/dist/ directory.","title":"Source code"},{"location":"contributing/server/#middlewares","text":"All Express Middlewares are in /api/src/middlewares/ and need to be manually loaded by /api/src/Server.ts .","title":"Middlewares"},{"location":"contributing/server/#routes","text":"All Express Router routes are in /api/src/routes/ and are automatically registered based on the file structure.","title":"Routes"},{"location":"contributing/server/#models","text":"All database TypeORM entities are located in /util/src/entities","title":"Models"},{"location":"contributing/server/#util","text":"All Utility functions are in the directory /src/util/ and in @fosscord/util","title":"Util"},{"location":"contributing/server/#configuration","text":"","title":"Configuration"},{"location":"contributing/server/#philosophy","text":"Every fosscord server instance should be completely configurable in every way, without the need to change the source code. The config should have reasonable defaults similar to discord. Only in special cases it should require a third party config value. The config should be changeable over the admin fosscord-dashboard and update in realtime without the need to restart the servers The very first time the server starts, it saves to default config in the database. The next start it will load the config from the database.","title":"Philosophy"},{"location":"contributing/server/#example","text":"You should not get() the Config in the root of your file and it instead load the config every time you access a value Import Config from fosscord-server-util: // at the top of the file import the Config file from /src/util/Config.ts import { Config } from \"@fosscord-server-util\" ; Access the Config in your route: router . get ( \"/\" , ( req : Request , res : Response ) => { // call Config.get() to get the whole config object and then just access the property you want const { allowNewRegistration } = Config . get (). register ; }); Config.get() returns the current config object and is not expensive at all","title":"Example"},{"location":"contributing/server/#extending","text":"The default Config is located in server-util /src/util/Config.ts and exports a interface DefaultOptions and a const DefaultOptions object with reasonable default values. To add your own values to the config, add the properties to the interface with corresponding types and add default values to const DefaultOptions . Also you don't need to worry about updating \"old config versions\", because new values will automatically be synced with the database. Note, however, that if the database already has a default value it won't update it.","title":"Extending"},{"location":"contributing/server/#routes_1","text":"All routes are located in the directory /src/routes/ and are loaded on start by a the lambert-server package. The HTTP API path is generated automatically based on the folder structure, so it is important that you name your files accordingly. If you want to use URL Params like :id in e.g. /users/:id you need to use # instead of : for the folder/filename, because of file naming issues on windows. index.ts files won't serve /api/index and instead alias the parent folder e.g. /api/ Your file needs to default export a express.Router() : import { Router } from express ; const router = Router (); export default router ; Now you can just use any regular express function on the router variable e.g: router . get ( \"/\" , ( req , res ) => {}); router . post ( \"/\" , ( req , res ) => {}); router . get ( \"/members\" , ( req , res ) => {});","title":"Routes"},{"location":"contributing/server/#authentication","text":"Every request must contain the authorization header except the /login and /register route. You can add additional non-auth routes in /src/middlewares/Authentication.ts To access the user id for the current request use req.user_id","title":"Authentication"},{"location":"contributing/server/#body-validation","text":"We use a custom body validation logic from lambert-server to check if the JSON body is valid. To import the function from /src/util/instanceOf.ts use: import { check } from \"/src/util/instanceOf\" ; Now you can use the middleware check for your routes by calling check with your Body Schema. router . post ( \"/\" , check (...), ( req , res ) => {});","title":"Body Validation"},{"location":"contributing/server/#schema","text":"A Schema is a Object Structure with key-value objects that checks if the supplied body is an instance of the specified class. { id : String , roles : [ String ] } Notice if you use e.g. BigInt even if you can't supply it with JSON, it will automatically convert the supplied JSON number/string to a BigInt. Also if you want to check for an array of, just put the type inside []","title":"Schema"},{"location":"contributing/server/#optional-parameter","text":"You can specify optional parameters if you prefix the key with a $ (dollar sign) e.g.: { $captcha: String } , this will make the captcha property in the body optional.","title":"Optional Parameter"},{"location":"contributing/server/#limit-string-length","text":"Additionally import the class Length from instanceOf and specify the type by making a new Length Object taking following parameters: import { Length } from \"/src/util/instanceOf\" ; const min = 2 ; const max = 32 ; const type = String ; { username : new Length ( min , max , type ); } this will limit the maximum string/number/array length to the min and max value.","title":"Limit String length"},{"location":"contributing/server/#example_1","text":"import { check , Length } from \"/src/util/instanceOf\" ; const SCHEMA = { username : new Length ( 2 , 32 , String ), age : Number , $posts : [{ title : String }] }; app . post ( \"/\" , check ( SCHEMA ), ( req , res ) => {});","title":"Example"},{"location":"contributing/server/#throw-errors","text":"If the body validation fails it will automatically throw an error. The errors structure is a key-value Object describing what field contained the error: { \"code\" : 50035 , \"message\" : \"Invalid Form Body\" , \"errors\" : { \"email\" : { \"_errors\" : [ { \"message\" : \"Email is already registered\" , \"code\" : \"EMAIL_ALREADY_REGISTERED\" } ] }, \"username\" : { \"_errors\" : [ { \"message\" : \"Must be between 2 - 32 in length\" , \"code\" : \"BASE_TYPE_BAD_LENGTH\" } ] } } } To manually throw a FieldError import FieldErrors import { FieldErrors } from / src / iltu / instanceOf ; To make sure your errors are understood in all languages translate it with i18next and req.t So after you have checked the field is invalid throw the FieldErrors throw FieldErrors (( login : { message : req.t ( \"auth:login.INVALID_LOGIN\" ), code : \"INVALID_LOGIN\" }});","title":"Throw Errors"},{"location":"contributing/server/#database","text":"","title":"Database"},{"location":"contributing/server/#philosophy_1","text":"The instance hoster should be able to use any database they want for their specific size and purpose. That is why we use typeorm for database entities (models) for every data structure we use, because typeorm supports many different database engines. We use strings for all ids and bitfields (Tho when working with bitfields we convert it to BigInts and pass it to the utility BitField class)","title":"Philosophy"},{"location":"contributing/server/#general","text":"Have a look at the typeorm documentation to get familiar with it or watch this tutorial . TypeORM supports MySQL, MariaDB, Postgres, CockroachDB, SQLite, Microsoft SQL Server, Oracle, SAP Hana, sql.js","title":"General"},{"location":"contributing/server/#getting-started","text":"Import the entity you want to select, manipulate, delete or insert from @fosscord/util List of all entities : Application, Attachment, AuditLog, Ban, BaseClass, Channel, Config, ConnectedAccount, Emoji, Guild, Invite, Member, Message, RateLimit, ReadState, Recipient, Relationship, Role, Sticker, Team, TeamMember, Template, User, VoiceState, Webhook","title":"Getting Started"},{"location":"contributing/server/#example-database-query","text":"import { Guild } from \"fosscord-server-util\" ; await new Guild ({ ... }). save (); // inserts a new guild or updates it if it already exists const guild = await Guild . findOne ({ id : \"23948723947932\" }). exec (); // searches for a guild await Guild . delete ({ owner_id : \"34975309473\" }) // deletes all guilds of the specific owner","title":"Example database query"},{"location":"contributing/server/#entities","text":"The typeorm database entities are located in util/src/entities/ . To add your own database entity, create a new file, export the model and import/export it in util/src/entities/index.ts .","title":"Entities"},{"location":"contributing/server/#example-entity","text":"@Entity ( \"users\" ) export class User extends BaseClass { // id column is automatically added by BaseClass @Column () username : string ; @JoinColumn ({ name : \"connected_account_ids\" }) @OneToMany (() => ConnectedAccount , ( account : ConnectedAccount ) => account . user ) connected_accounts : ConnectedAccount []; static async getPublicUser ( user_id : string , opts? : FindOneOptions < User > ) { return await User . findOneOrFail ( { id : user_id }, { ... opts , select : [... PublicUserProjection , ...( opts ? . select || [])] } ); } }","title":"Example entity"},{"location":"contributing/server/#emit-events","text":"Most Routes modify the database and therefore need to inform the clients with events for data changes. Events are either stored locally if the server was started through the bundle or in RabbitMQ and are distributed to the gateway servers. You can find all events on the discord docs page and in util/src/interfaces/Event.ts . To emit an event import the emitEvent function from @fosscord/util import { emitEvent } from \"../../../util/Event\" ; You need to specify whom you want to send the event to, to do that either pass guild_id , user_id or channel_id . Additionally you need to set the eventname e.g. GUILD_DELETE . { guild_id? : bigint ; // specify this if this event should be sent to all guild members channel_id? : bigint ; // specify this if this event should be sent to all channel members user_id? : bigint ; // specify this if this event should be sent to the specific user event : string ; // the EVENTNAME, you can find all gateway event names in the @fosscord/util Events file data? : any ; // event payload data } For easy intellisense, annotate the parameter with the corresponding Event interface from @fosscord/util : import { GuildDeleteEvent } from \"@fosscord/util\" ; emitEvent ({...} as GuildDeleteEvent );","title":"Emit Events"},{"location":"contributing/server/#example_2","text":"Putting it all together: await emitEvent ({ user_id : \"3297349345345874\" , event : \"GUILD_DELETE\" , data : { id : \"96784598743975349\" , }, } as GuildDeleteEvent );","title":"Example"},{"location":"contributing/server/#permissions","text":"To get the permission for a guild member import the getPermission from fosscord-server-util . import { getPermission } from \"fosscord-server-util\" ; The first argument is the user_id the second the guild_id and the third an optional channel_id const permissions = await getPermission ( user_id : string , guild_id : string , channel_id? : string ) const permissions = await getPermission ( \"106142653265366125\" , \"4061326832657368175\" )","title":"Permissions"},{"location":"contributing/server/#example_3","text":"const perms = await getPermission ( req . userid , guild_id ); // preferred method: Use this if you want to check if a user lacks a certain permission and abort the operation perms . hasThrow ( \"MANAGE_GUILD\" ) // will throw an error if the users lacks the permission if ( perms . has ( \"MANAGE_GUILD\" )) { ... }","title":"Example"},{"location":"contributing/ui/","text":"UI Framework see: @fosscord/ui Requirements You should be familiar with: Git NodeJS SCSS Getting Started git clone https://github.com/fosscord/fosscord-ui cd fosscord-ui npm install npm run scss Open ./test/index.html to see the test page. Writing a component text inside of <> has to be replaced by the corresponding values create a file named like the component you're creating in test/<component>.html and scss/<component>.scss copy the content of test/template.html to test/<component>.html and replace the <h1> content with the components name source the created test/<component>.html> in test/index.html as follows: append the following to scss/index.scss to the div with the class \"grid\" < a class = \"Link\" href = \"<component>.html\" class = \"text link\" > < component > </ a > source the created scss/<component>.scss in scss/index.scss as follows: append the following to scss/index.scss ... @ import \"<component>.scss\" ;","title":"UI Framework"},{"location":"contributing/ui/#ui-framework","text":"see: @fosscord/ui","title":"UI Framework"},{"location":"contributing/ui/#requirements","text":"You should be familiar with: Git NodeJS SCSS","title":"Requirements"},{"location":"contributing/ui/#getting-started","text":"git clone https://github.com/fosscord/fosscord-ui cd fosscord-ui npm install npm run scss Open ./test/index.html to see the test page.","title":"Getting Started"},{"location":"contributing/ui/#writing-a-component","text":"text inside of <> has to be replaced by the corresponding values create a file named like the component you're creating in test/<component>.html and scss/<component>.scss copy the content of test/template.html to test/<component>.html and replace the <h1> content with the components name source the created test/<component>.html> in test/index.html as follows: append the following to scss/index.scss to the div with the class \"grid\" < a class = \"Link\" href = \"<component>.html\" class = \"text link\" > < component > </ a > source the created scss/<component>.scss in scss/index.scss as follows: append the following to scss/index.scss ... @ import \"<component>.scss\" ;","title":"Writing a component"}]}