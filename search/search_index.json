{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home What is Fosscord? Fosscord is a free open source selfhostable chat, voice and video discord-compatible platform Why the name Fosscord? Fosscord is a combination of the abbreviation FOSS ( F ree O pen S ource S oftware) and the name Dis cord . Philosophy Fosscord aims to be a full one-on-one clone of Discord, adding more features that can be used as a replacement for the official client and still connect to discord.com and host private Fosscord server instances. Fosscord aims to give the best possible user experience, while being backwards compatible to Discord's features and adding new ones/improving old ones while maintaining the user privacy with end-to-end encryption support. The client can connect to multiple server instances without the need to open it multiple times. The client should be extensible through a secure Plugin and Theme System with own store. The server should be extensible through bots, just like discord without the need to change anything except the api endpoint. The project is open source so everyone can have a look what's going on under the hood and can be maintained and expanded by the community. Everything is configurable in the server config and everyone can add their own features, so that it is not opinionated. Concept Why backwards compatible to Discord? Benefit from the large user base of discord -> more users, making the switch easier for new users & keeping workflows intact No disadvantage for the users who use fosscord, so that they can still communicate with all their peers who use discord Discord has already built a great and stable protocol (don't reinvent the wheel) The community can extend and customize their clients and servers by selfhosting them and developing and installing addons Support Discord server Ones we are finished, we'll host our own instance to host the support server.","title":"Home"},{"location":"#home","text":"","title":"Home"},{"location":"#what-is-fosscord","text":"Fosscord is a free open source selfhostable chat, voice and video discord-compatible platform","title":"What is Fosscord?"},{"location":"#why-the-name-fosscord","text":"Fosscord is a combination of the abbreviation FOSS ( F ree O pen S ource S oftware) and the name Dis cord .","title":"Why the name Fosscord?"},{"location":"#philosophy","text":"Fosscord aims to be a full one-on-one clone of Discord, adding more features that can be used as a replacement for the official client and still connect to discord.com and host private Fosscord server instances. Fosscord aims to give the best possible user experience, while being backwards compatible to Discord's features and adding new ones/improving old ones while maintaining the user privacy with end-to-end encryption support. The client can connect to multiple server instances without the need to open it multiple times. The client should be extensible through a secure Plugin and Theme System with own store. The server should be extensible through bots, just like discord without the need to change anything except the api endpoint. The project is open source so everyone can have a look what's going on under the hood and can be maintained and expanded by the community. Everything is configurable in the server config and everyone can add their own features, so that it is not opinionated.","title":"Philosophy"},{"location":"#concept","text":"","title":"Concept"},{"location":"#why-backwards-compatible-to-discord","text":"Benefit from the large user base of discord -> more users, making the switch easier for new users & keeping workflows intact No disadvantage for the users who use fosscord, so that they can still communicate with all their peers who use discord Discord has already built a great and stable protocol (don't reinvent the wheel) The community can extend and customize their clients and servers by selfhosting them and developing and installing addons","title":"Why backwards compatible to Discord?"},{"location":"#support","text":"Discord server Ones we are finished, we'll host our own instance to host the support server.","title":"Support"},{"location":"contributing/","text":"Contributing Setup Follow the server setup guide to setup the development environment Contribution guide coming soon.","title":"Contributing"},{"location":"contributing/#contributing","text":"","title":"Contributing"},{"location":"contributing/#setup","text":"Follow the server setup guide to setup the development environment Contribution guide coming soon.","title":"Setup"},{"location":"encryption/","text":"Encryption Philosophy Everything should be end-to-end encrypted by default. Everything should be configurable by the user/admin to their security needs. Once encryption is enabled you can't disable it anymore. (Plain text channels need be created as such) End to end encryption should also be possible on unsupported servers e.g. discord.com. (through special formatted messages) Based on the concept that the server cannot be trusted and could be compromised.","title":"Encryption"},{"location":"encryption/#encryption","text":"","title":"Encryption"},{"location":"encryption/#philosophy","text":"Everything should be end-to-end encrypted by default. Everything should be configurable by the user/admin to their security needs. Once encryption is enabled you can't disable it anymore. (Plain text channels need be created as such) End to end encryption should also be possible on unsupported servers e.g. discord.com. (through special formatted messages) Based on the concept that the server cannot be trusted and could be compromised.","title":"Philosophy"},{"location":"plugins/","text":"Philosophy Plugins are executed in their environment to prevent security issues Plugins can create their own UI and loaded in a separate view (similar to vscode extensions) Plugins can access the component Api and therefore extend the client UI Plugins can access the WebSocket Connection/Rest API and intercept/transform events Plugins are restricted and can only do actions with the corresponding permission Plugins should be accessible through a store that needs to verify the plugins (with dev options to sideload plugins/add other stores) Permissions Can't access the user's token (token plugins should rather be directly integrated into the client (e.g. account switcher)) All permissions must meet the purpose of the plugin and must justify why they need the certain permission to be approved Shouldn't be able to make any request, except if it: Requests permission to access the api of the network Requests permission to access a specific domain (e.g. plugins backend) Requests permission to access all domains Shouldn't be able to intercept events, except if it: Requests permission to a specific event(s) Requests permission to all events Needs to request permission to be able to extend the client's UI","title":"Plugins"},{"location":"plugins/#philosophy","text":"Plugins are executed in their environment to prevent security issues Plugins can create their own UI and loaded in a separate view (similar to vscode extensions) Plugins can access the component Api and therefore extend the client UI Plugins can access the WebSocket Connection/Rest API and intercept/transform events Plugins are restricted and can only do actions with the corresponding permission Plugins should be accessible through a store that needs to verify the plugins (with dev options to sideload plugins/add other stores)","title":"Philosophy"},{"location":"plugins/#permissions","text":"Can't access the user's token (token plugins should rather be directly integrated into the client (e.g. account switcher)) All permissions must meet the purpose of the plugin and must justify why they need the certain permission to be approved Shouldn't be able to make any request, except if it: Requests permission to access the api of the network Requests permission to access a specific domain (e.g. plugins backend) Requests permission to access all domains Shouldn't be able to intercept events, except if it: Requests permission to a specific event(s) Requests permission to all events Needs to request permission to be able to extend the client's UI","title":"Permissions"},{"location":"resources/","text":"Links Documentation Roadmap (Notion to-do board synced with GitHub issues) Status (Status page of the offical foscord instance) GitHub (GitHub organization) OpenCollective (Financially support the project to cover server costs and other expenses) Discord server (for support & organization (If we are finished we'll host our own support server)) Tor Hidden Service (Better privacy for TOR users) Project structure Fosscord consists of many repositories, which together make up the client and the server: Server fosscord-server is the complete Fosscord Server Contains: - gateway is the WebSocket Gateway server - rtc will be the rtc server for voice and video sharing. - webrtc-server is a javascript fosscord webrtc server for voice and video communication - dashboard An admin dashboard for the server (analytics, settings, administration, trust & safety) - util contains all shared logic like Database Models, Utility functions... - cdn is the content-delivery-content (CDN) that stores user uploaded images. Client fosscord-ui is a user interface framework in the style of discord. fosscord-themes contains all the official themes for the client. fosscord-plugins contains all the official plugins for the client. fosscord-client is the official Fosscord client. fosscord-client-native is the official (react)-native Fosscord client. ~~ react-native-withcss CSS support for react native~~ (Discontinued) ~~ css-mediaquery CSS media query support for react native~~ (Discontinued) Others fosscord-docs Documentation of Fosscord fosscord-landingpage represents and explains the project. fosscord.js A powerful JavaScript library for interacting with the Fosscord API fosscord.js-builders A collection of builders that you can use when creating your bot. fosscord.py An API wrapper for Fosscord written in Python. docker \ud83d\udc33 Fosscord's Docker images and composing","title":"Resources"},{"location":"resources/#links","text":"Documentation Roadmap (Notion to-do board synced with GitHub issues) Status (Status page of the offical foscord instance) GitHub (GitHub organization) OpenCollective (Financially support the project to cover server costs and other expenses) Discord server (for support & organization (If we are finished we'll host our own support server)) Tor Hidden Service (Better privacy for TOR users)","title":"Links"},{"location":"resources/#project-structure","text":"Fosscord consists of many repositories, which together make up the client and the server:","title":"Project structure"},{"location":"resources/#server","text":"fosscord-server is the complete Fosscord Server Contains: - gateway is the WebSocket Gateway server - rtc will be the rtc server for voice and video sharing. - webrtc-server is a javascript fosscord webrtc server for voice and video communication - dashboard An admin dashboard for the server (analytics, settings, administration, trust & safety) - util contains all shared logic like Database Models, Utility functions... - cdn is the content-delivery-content (CDN) that stores user uploaded images.","title":"Server"},{"location":"resources/#client","text":"fosscord-ui is a user interface framework in the style of discord. fosscord-themes contains all the official themes for the client. fosscord-plugins contains all the official plugins for the client. fosscord-client is the official Fosscord client. fosscord-client-native is the official (react)-native Fosscord client. ~~ react-native-withcss CSS support for react native~~ (Discontinued) ~~ css-mediaquery CSS media query support for react native~~ (Discontinued)","title":"Client"},{"location":"resources/#others","text":"fosscord-docs Documentation of Fosscord fosscord-landingpage represents and explains the project. fosscord.js A powerful JavaScript library for interacting with the Fosscord API fosscord.js-builders A collection of builders that you can use when creating your bot. fosscord.py An API wrapper for Fosscord written in Python. docker \ud83d\udc33 Fosscord's Docker images and composing","title":"Others"},{"location":"setup/","text":"Setup Server Download This is the stable fosscord-server release. Download the server release from GitHub for your operating system. (Size ~60mb) Double click the file to start the server. (The first time it takes longer as it needs to setup the server) You can now access it on http://localhost:3001 . With terminal/shell This is the latest bleeding edge version of fosscord-server, which may have bugs. You need to install git from git-scm.com or your package manager. You need to install nodejs from nodejs.org or your package manager. Now you can clone and start the server, by executing this in the terminal/shell: git clone https://github.com/fosscord/fosscord-server cd fosscord-server/bundle npm install npm start You can now access it on http://localhost:3001 Docker Optionally if you want to use Docker: git clone https://github.com/fosscord/fosscord-server cd fosscord-server docker-compose up You can now access it on http://localhost:3001 Client Our client is not ready for the public. ( help contributing ) However the server already has a discord test client built in, which can be used to access Fosscord.","title":"Setup"},{"location":"setup/#setup","text":"","title":"Setup"},{"location":"setup/#server","text":"","title":"Server"},{"location":"setup/#download","text":"This is the stable fosscord-server release. Download the server release from GitHub for your operating system. (Size ~60mb) Double click the file to start the server. (The first time it takes longer as it needs to setup the server) You can now access it on http://localhost:3001 .","title":"Download"},{"location":"setup/#with-terminalshell","text":"This is the latest bleeding edge version of fosscord-server, which may have bugs. You need to install git from git-scm.com or your package manager. You need to install nodejs from nodejs.org or your package manager. Now you can clone and start the server, by executing this in the terminal/shell: git clone https://github.com/fosscord/fosscord-server cd fosscord-server/bundle npm install npm start You can now access it on http://localhost:3001","title":"With terminal/shell"},{"location":"setup/#docker","text":"Optionally if you want to use Docker: git clone https://github.com/fosscord/fosscord-server cd fosscord-server docker-compose up You can now access it on http://localhost:3001","title":"Docker"},{"location":"setup/#client","text":"Our client is not ready for the public. ( help contributing ) However the server already has a discord test client built in, which can be used to access Fosscord.","title":"Client"},{"location":"api/","text":"API Status overview This is the fosscord HTTP API Server. Every routes has its own issue . For documentation, head over to the Discord docs . If you want to work on a feature please comment on the corresponding issue so we can assign it you that nobody implements something twice.","title":"API"},{"location":"api/#api","text":"","title":"API"},{"location":"api/#status-overview","text":"This is the fosscord HTTP API Server. Every routes has its own issue . For documentation, head over to the Discord docs . If you want to work on a feature please comment on the corresponding issue so we can assign it you that nobody implements something twice.","title":"Status overview"},{"location":"api/configuration/","text":"Configuration Philosophy Every fosscord server instance should be completely configurable in every way, without the need to change the source code. The config should have reasonable defaults similar to discord. Only in special cases it should require a third party config value. The config should be changeable over the admin fosscord-dashboard and update in realtime without the need to restart the servers The very first time the server starts, it saves to default config in the database. The next start it will load the config from the database. Getting Started for Contributors You should not get() the Config in the root of your file and it instead load the config every time you access a value Import Config from fosscord-server-util: // at the top of the file import the Config file from /src/util/Config.ts import { Config } from \"@fosscord-server-util\" ; Access the Config in your route: router . get ( \"/\" , ( req : Request , res : Response ) => { // call Config.get() to get the whole config object and then just access the property you want const { allowNewRegistration } = Config . get (). register ; }); Config.get() returns the current config object and is not expensive at all Add own values to the Config The default Config is located in server-util /src/util/Config.ts and exports a interface DefaultOptions and a const DefaultOptions object with reasonable default values. To add your own values to the config, add the properties to the interface with corresponding types and add default values to const DefaultOptions . Also you don't need to worry about updating \"old config versions\", because new values will automatically be synced with the database. Note, however, that if the database already has a default value it won't update it.","title":"Configuration"},{"location":"api/configuration/#configuration","text":"","title":"Configuration"},{"location":"api/configuration/#philosophy","text":"Every fosscord server instance should be completely configurable in every way, without the need to change the source code. The config should have reasonable defaults similar to discord. Only in special cases it should require a third party config value. The config should be changeable over the admin fosscord-dashboard and update in realtime without the need to restart the servers The very first time the server starts, it saves to default config in the database. The next start it will load the config from the database.","title":"Philosophy"},{"location":"api/configuration/#getting-started-for-contributors","text":"You should not get() the Config in the root of your file and it instead load the config every time you access a value Import Config from fosscord-server-util: // at the top of the file import the Config file from /src/util/Config.ts import { Config } from \"@fosscord-server-util\" ; Access the Config in your route: router . get ( \"/\" , ( req : Request , res : Response ) => { // call Config.get() to get the whole config object and then just access the property you want const { allowNewRegistration } = Config . get (). register ; }); Config.get() returns the current config object and is not expensive at all","title":"Getting Started for Contributors"},{"location":"api/configuration/#add-own-values-to-the-config","text":"The default Config is located in server-util /src/util/Config.ts and exports a interface DefaultOptions and a const DefaultOptions object with reasonable default values. To add your own values to the config, add the properties to the interface with corresponding types and add default values to const DefaultOptions . Also you don't need to worry about updating \"old config versions\", because new values will automatically be synced with the database. Note, however, that if the database already has a default value it won't update it.","title":"Add own values to the Config"},{"location":"api/route/","text":"General All routes are located in the directory /src/routes/ and are loaded on start by a the lambert-server package. The HTTP API path is generated automatically based on the folder structure, so it is important that you name your files accordingly. If you want to use URL Params like :id in e.g. /users/:id you need to use # instead of : for the folder/filename, because of file naming issues on windows. index.ts files won't serve /api/index and instead alias the parent folder e.g. /api/ Your file needs to default export a express.Router() : import { Router } from express const router = Router (); export default router ; Now you can just use any regular express function on the router variable e.g: router . get ( \"/\" , ( req , res ) => {}); router . post ( \"/\" , ( req , res ) => {}); router . get ( \"/members\" , ( req , res ) => {}); Authentication Every request must contain the authorization header except the /login and /register route. You can add additional non-auth routes in /src/middlewares/Authentication.ts To access the user id for the current request use req.user_id Body Validation We use a custom body validation logic from lambert-server to check if the JSON body is valid. To import the function from /src/util/instanceOf.ts use: import { check } from \"/src/util/instanceOf\" ; Now you can use the middleware check for your routes by calling check with your Body Schema. router . post ( \"/\" , check (...), ( req , res ) => {}); Schema A Schema is a Object Structure with key-value objects that checks if the supplied body is an instance of the specified class. { id : String , roles : [ String ] } Notice if you use e.g. BigInt even if you can't supply it with JSON, it will automatically convert the supplied JSON number/string to a BigInt. Also if you want to check for an array of, just put the type inside [] Optional Parameter You can specify optional parameters if you prefix the key with a $ (dollar sign) e.g.: { $captcha: String } , this will make the captcha property in the body optional. Limit String length Additionally import the class Length from instanceOf and specify the type by making a new Length Object taking following parameters: import { Length } from \"/src/util/instanceOf\" ; const min = 2 ; const max = 32 ; const type = String ; { username : new Length ( min , max , type ) } this will limit the maximum string/number/array length to the min and max value. Example: import { check , Length } from \"/src/util/instanceOf\" ; const SCHEMA = { username : new Length ( 2 , 32 , String ), age : Number , $posts : [{ title : String }] } app . post ( \"/\" , check ( SCHEMA ), ( req , res ) => {}); Throw Errors If the body validation fails it will automatically throw an error. The errors structure is a key-value Object describing what field contained the error: { \"code\" : 50035 , \"message\" : \"Invalid Form Body\" , \"errors\" : { \"email\" : { \"_errors\" : [ { \"message\" : \"Email is already registered\" , \"code\" : \"EMAIL_ALREADY_REGISTERED\" } ] }, \"username\" : { \"_errors\" : [ { \"message\" : \"Must be between 2 - 32 in length\" , \"code\" : \"BASE_TYPE_BAD_LENGTH\" } ] } } } To manually throw a FieldError import FieldErrors import { FieldErrors } from / src / util / instanceOf To make sure your errors are understood in all languages translate it with i18next and req.t So after you have checked the field is invalid throw the FieldErrors throw FieldErrors (( login : { message : req.t ( \"auth:login.INVALID_LOGIN\" ), code : \"INVALID_LOGIN\" }});","title":"Route"},{"location":"api/route/#general","text":"All routes are located in the directory /src/routes/ and are loaded on start by a the lambert-server package. The HTTP API path is generated automatically based on the folder structure, so it is important that you name your files accordingly. If you want to use URL Params like :id in e.g. /users/:id you need to use # instead of : for the folder/filename, because of file naming issues on windows. index.ts files won't serve /api/index and instead alias the parent folder e.g. /api/ Your file needs to default export a express.Router() : import { Router } from express const router = Router (); export default router ; Now you can just use any regular express function on the router variable e.g: router . get ( \"/\" , ( req , res ) => {}); router . post ( \"/\" , ( req , res ) => {}); router . get ( \"/members\" , ( req , res ) => {});","title":"General"},{"location":"api/route/#authentication","text":"Every request must contain the authorization header except the /login and /register route. You can add additional non-auth routes in /src/middlewares/Authentication.ts To access the user id for the current request use req.user_id","title":"Authentication"},{"location":"api/route/#body-validation","text":"We use a custom body validation logic from lambert-server to check if the JSON body is valid. To import the function from /src/util/instanceOf.ts use: import { check } from \"/src/util/instanceOf\" ; Now you can use the middleware check for your routes by calling check with your Body Schema. router . post ( \"/\" , check (...), ( req , res ) => {});","title":"Body Validation"},{"location":"api/route/#schema","text":"A Schema is a Object Structure with key-value objects that checks if the supplied body is an instance of the specified class. { id : String , roles : [ String ] } Notice if you use e.g. BigInt even if you can't supply it with JSON, it will automatically convert the supplied JSON number/string to a BigInt. Also if you want to check for an array of, just put the type inside []","title":"Schema"},{"location":"api/route/#optional-parameter","text":"You can specify optional parameters if you prefix the key with a $ (dollar sign) e.g.: { $captcha: String } , this will make the captcha property in the body optional.","title":"Optional Parameter"},{"location":"api/route/#limit-string-length","text":"Additionally import the class Length from instanceOf and specify the type by making a new Length Object taking following parameters: import { Length } from \"/src/util/instanceOf\" ; const min = 2 ; const max = 32 ; const type = String ; { username : new Length ( min , max , type ) } this will limit the maximum string/number/array length to the min and max value.","title":"Limit String length"},{"location":"api/route/#example","text":"import { check , Length } from \"/src/util/instanceOf\" ; const SCHEMA = { username : new Length ( 2 , 32 , String ), age : Number , $posts : [{ title : String }] } app . post ( \"/\" , check ( SCHEMA ), ( req , res ) => {});","title":"Example:"},{"location":"api/route/#throw-errors","text":"If the body validation fails it will automatically throw an error. The errors structure is a key-value Object describing what field contained the error: { \"code\" : 50035 , \"message\" : \"Invalid Form Body\" , \"errors\" : { \"email\" : { \"_errors\" : [ { \"message\" : \"Email is already registered\" , \"code\" : \"EMAIL_ALREADY_REGISTERED\" } ] }, \"username\" : { \"_errors\" : [ { \"message\" : \"Must be between 2 - 32 in length\" , \"code\" : \"BASE_TYPE_BAD_LENGTH\" } ] } } } To manually throw a FieldError import FieldErrors import { FieldErrors } from / src / util / instanceOf To make sure your errors are understood in all languages translate it with i18next and req.t So after you have checked the field is invalid throw the FieldErrors throw FieldErrors (( login : { message : req.t ( \"auth:login.INVALID_LOGIN\" ), code : \"INVALID_LOGIN\" }});","title":"Throw Errors"},{"location":"api/structure/","text":"Translation We use i18next to manage translation/localization in some API Responses. The .json language files are located in /locales and are separated by namespaces. Source code We use TypeScript (JavaScript with types). The .ts source files are located in /src/ and will be compiled to .js in the /dist/ directory. Middlewares All Express Middlewares are in the directory /src/middlewares/ and need to be manually loaded in /src/Server.ts . Routes All Express Router Routes are in the directory /src/routes/ and are automatically registered based on the file structure. Models All Database Typescript interface models are in the directory /src/models/ Util All Utility functions are in the directory /src/util/ .","title":"Structure"},{"location":"api/structure/#translation","text":"We use i18next to manage translation/localization in some API Responses. The .json language files are located in /locales and are separated by namespaces.","title":"Translation"},{"location":"api/structure/#source-code","text":"We use TypeScript (JavaScript with types). The .ts source files are located in /src/ and will be compiled to .js in the /dist/ directory.","title":"Source code"},{"location":"api/structure/#middlewares","text":"All Express Middlewares are in the directory /src/middlewares/ and need to be manually loaded in /src/Server.ts .","title":"Middlewares"},{"location":"api/structure/#routes","text":"All Express Router Routes are in the directory /src/routes/ and are automatically registered based on the file structure.","title":"Routes"},{"location":"api/structure/#models","text":"All Database Typescript interface models are in the directory /src/models/","title":"Models"},{"location":"api/structure/#util","text":"All Utility functions are in the directory /src/util/ .","title":"Util"},{"location":"client/","text":"","title":"Client"},{"location":"gateway/","text":"Gateway Status overview This is the fosscord WebSocket Gateway Server. For documentation, head over to the Discord docs . If you want to work on a feature please comment on the corresponding issue so we can assign it you that nobody implements something twice.","title":"Gateway"},{"location":"gateway/#gateway","text":"","title":"Gateway"},{"location":"gateway/#status-overview","text":"This is the fosscord WebSocket Gateway Server. For documentation, head over to the Discord docs . If you want to work on a feature please comment on the corresponding issue so we can assign it you that nobody implements something twice.","title":"Status overview"},{"location":"gateway/structure/","text":"For the WebSocket, we use ws and we'll write our own packet handler for the individual opcodes and events.","title":"Structure"},{"location":"server_util/database/","text":"Database Philosophy We create mongoose models and typescript interfaces for every data structure in the database. We use strings for all id's and for bitfields we use bigint's Documentation Have a look at the mongoose documentation to get familiar with it or watch this tutorial Getting Started import mongoose from \"mongoose\" ; and now you can query the database, here are some examples: import { GuildModel } from \"fosscord-server-util\" ; await new GuildModel ({ ... }). save (); // inserts a new guild const guild = await GuildModel . findOne ({ id : ... }). exec (); // searches for a guild Models We have mongoose Database Models and additionally TypeScript Interfaces . They are located in the repo fosscord-server-util under /src/models/ . To add your own Database Model, create a new file and export the model and the interface. Example: export interface Event extends Document { guild_id? : bigint ; user_id? : bigint ; channel_id? : bigint ; created_at? : number ; event : EVENT ; data? : any ; } export const EventSchema = new Schema ({ guild_id : Types.Long , user_id : Types.Long , channel_id : Types.Long , created_at : { type : Number , required : true }, event : { type : String , required : true }, data : Object , }); export const EventModel = model < Event > ( \"Event\" , EventSchema , \"events\" ); Emit events Most Routes modify the database and therefore need to inform the clients with events for data changes. (Events are stored in a MongoDB Event Store collection and distributed to the individual gateway servers) You can find all events on the discord docs page and in server-util/src/modesl/Event.ts To emit an event import the emitEvent function from /src/util/Event.ts import { emitEvent } from \"../../../util/Event\" ; this will take a the following parameters: { guild_id? : bigint ; // specify this if this event should be sent to all guild members channel_id? : bigint ; // specify this if this event should be sent to all channel members (e.g. group dm) user_id? : bigint ; // specify this if this event should be sent to the specific user event : string ; // the EVENTNAME, you can find all gateway event names in the fosscord-server-util Events file data? : any ; // event payload data } For easy intellisense, annotate the parameter with the corresponding Event interface from fosscord-server-util : import { GuildDeleteEvent } from \"fosscord-server-util\" ; emitEvent ({...} as GuildDeleteEvent ); // or with <> brackets: emitEvent ( < GuildDeleteEvent > {...}); Example Putting it all together: await emitEvent ({ event : \"GUILD_DELETE\" , data : { id : guildID , }, guild_id : guildID , } as GuildDeleteEvent );","title":"Database"},{"location":"server_util/database/#database","text":"","title":"Database"},{"location":"server_util/database/#philosophy","text":"We create mongoose models and typescript interfaces for every data structure in the database. We use strings for all id's and for bitfields we use bigint's","title":"Philosophy"},{"location":"server_util/database/#documentation","text":"Have a look at the mongoose documentation to get familiar with it or watch this tutorial","title":"Documentation"},{"location":"server_util/database/#getting-started","text":"import mongoose from \"mongoose\" ; and now you can query the database, here are some examples: import { GuildModel } from \"fosscord-server-util\" ; await new GuildModel ({ ... }). save (); // inserts a new guild const guild = await GuildModel . findOne ({ id : ... }). exec (); // searches for a guild","title":"Getting Started"},{"location":"server_util/database/#models","text":"We have mongoose Database Models and additionally TypeScript Interfaces . They are located in the repo fosscord-server-util under /src/models/ . To add your own Database Model, create a new file and export the model and the interface. Example: export interface Event extends Document { guild_id? : bigint ; user_id? : bigint ; channel_id? : bigint ; created_at? : number ; event : EVENT ; data? : any ; } export const EventSchema = new Schema ({ guild_id : Types.Long , user_id : Types.Long , channel_id : Types.Long , created_at : { type : Number , required : true }, event : { type : String , required : true }, data : Object , }); export const EventModel = model < Event > ( \"Event\" , EventSchema , \"events\" );","title":"Models"},{"location":"server_util/database/#emit-events","text":"Most Routes modify the database and therefore need to inform the clients with events for data changes. (Events are stored in a MongoDB Event Store collection and distributed to the individual gateway servers) You can find all events on the discord docs page and in server-util/src/modesl/Event.ts To emit an event import the emitEvent function from /src/util/Event.ts import { emitEvent } from \"../../../util/Event\" ; this will take a the following parameters: { guild_id? : bigint ; // specify this if this event should be sent to all guild members channel_id? : bigint ; // specify this if this event should be sent to all channel members (e.g. group dm) user_id? : bigint ; // specify this if this event should be sent to the specific user event : string ; // the EVENTNAME, you can find all gateway event names in the fosscord-server-util Events file data? : any ; // event payload data } For easy intellisense, annotate the parameter with the corresponding Event interface from fosscord-server-util : import { GuildDeleteEvent } from \"fosscord-server-util\" ; emitEvent ({...} as GuildDeleteEvent ); // or with <> brackets: emitEvent ( < GuildDeleteEvent > {...});","title":"Emit events"},{"location":"server_util/database/#example","text":"Putting it all together: await emitEvent ({ event : \"GUILD_DELETE\" , data : { id : guildID , }, guild_id : guildID , } as GuildDeleteEvent );","title":"Example"},{"location":"server_util/permissions/","text":"To get the permission for a guild member import the getPermission from fosscord-server-util . import { getPermission } from \"fosscord-server-util\" ; The first argument is the user_id the second the guild_id and the third an optional channel_id const permissions = await getPermission ( user_id : string , guild_id : string , channel_id? : string ) const permissions = await getPermission ( \"106142653265366125\" , \"4061326832657368175\" ) Example const perms = await getPermission ( req . userid , guild_id ); // preferred method: Use this if you want to check if a user lacks a certain permission and abort the operation perms . hasThrow ( \"MANAGE_GUILD\" ) // will throw an error if the users lacks the permission if ( perms . has ( \"MANAGE_GUILD\" )) { ... }","title":"Permissions"},{"location":"server_util/permissions/#example","text":"const perms = await getPermission ( req . userid , guild_id ); // preferred method: Use this if you want to check if a user lacks a certain permission and abort the operation perms . hasThrow ( \"MANAGE_GUILD\" ) // will throw an error if the users lacks the permission if ( perms . has ( \"MANAGE_GUILD\" )) { ... }","title":"Example"},{"location":"ui/","text":"Status overview This UI Framework includes all static Fosscord CSS Components. Usage: View the demo and make use of its source code .","title":"Ui Framework"},{"location":"ui/#usage","text":"View the demo and make use of its source code .","title":"Usage:"},{"location":"ui/contribution_and_installation/","text":"Installation see: @fosscord/ui Contribution Requirements You should be familiar with: Git NodeJS SCSS Getting Started git clone https://github.com/fosscord/fosscord-ui cd fosscord-ui npm install npm run scss Open ./test/index.html to see the test page. Writing a component text inside of <> has to be replaced by the corresponding values create a file named like the component you're creating in test/<component>.html and scss/<component>.scss copy the content of test/template.html to test/<component>.html and replace the <h1> content with the components name source the created test/<component>.html> in test/index.html as follows: append the following to scss/index.scss to the div with the class \"grid\" < a class = \"Link\" href = \"<component>.html\" class = \"text link\" > < component > </ a > source the created scss/<component>.scss in scss/index.scss as follows: append the following to scss/index.scss ... @ import \"<component>.scss\" ;","title":"Installation"},{"location":"ui/contribution_and_installation/#installation","text":"see: @fosscord/ui","title":"Installation"},{"location":"ui/contribution_and_installation/#contribution","text":"","title":"Contribution"},{"location":"ui/contribution_and_installation/#requirements","text":"You should be familiar with: Git NodeJS SCSS","title":"Requirements"},{"location":"ui/contribution_and_installation/#getting-started","text":"git clone https://github.com/fosscord/fosscord-ui cd fosscord-ui npm install npm run scss Open ./test/index.html to see the test page.","title":"Getting Started"},{"location":"ui/contribution_and_installation/#writing-a-component","text":"text inside of <> has to be replaced by the corresponding values create a file named like the component you're creating in test/<component>.html and scss/<component>.scss copy the content of test/template.html to test/<component>.html and replace the <h1> content with the components name source the created test/<component>.html> in test/index.html as follows: append the following to scss/index.scss to the div with the class \"grid\" < a class = \"Link\" href = \"<component>.html\" class = \"text link\" > < component > </ a > source the created scss/<component>.scss in scss/index.scss as follows: append the following to scss/index.scss ... @ import \"<component>.scss\" ;","title":"Writing a component"}]}